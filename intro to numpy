numpy - numerical python -> backbone of data science, ML and other fields
Numpy is used over pure python as helps in doing complex calculations in shorter time as compared to pure python, bcoz of opt in C
uses vectorization via broadcasting ie avoiding writing loops

Main data type which is most oftenly used from the numpy library is - ndarray ( n dimensional array)
its attributes: 
1) shape -> shows the dimensions of the array
2) ndim -> shows the no. of dimensions
3) dtype -> shows the data type of elements in the aaray
4) size -> total no. of elements in the array

normal function (not a member):
type -> shows the type of array ie ndarray or numpy.ndarray

-> as pandas is built over numpy thus we can use ndarray to create a DataFrame coindition taht ndarray ndimhas to be 2

CREATING ARRAYS USING NUMPY
np.ones() -> takes the shape of the ndarray as the arg and returns an ndarray of the shape with each element as 1 in float
np.zeros() -> same as ones with element as 0 in float
np.arange() -> creates an array, takes start, stop(excluded) and step(gap between the elements), returns an array starting with start and followed by next step number, For floating point arguments, the length of the result is
    ``ceil((stop - start)/step)``.  Because of floating point overflow,
    this rule may result in the last element of `out` being greater
    than `stop`
using random module -> np.random.randint(start, end, shape =({shape of ndarray})) -> creates an ndarray of of given shape where each element belongs to range [start, end)
                    -> np.random.randome(({shape})) -> returns a ndarray of size as mentioned with random float values
                    -> np.random.rand({dimensions}) -> return a ndarray of random values, the returned ndarray is of dimensions as mentioned


The random numbers generated by random module aren't completely random(Pseudo random) -> they use a seed value against which these values are generated

if we use np.random.seed(seed={a random no}) -> this will keep all the random numbers generated aligned ie once an output is made using random, we will get same output on re running that piece of code
It basicaly tells Numpy to generated same set of numbers for a particular seed value
THIS IS USED WHEN WE SHARE OUR WORK WITH PEOPLE, WE NEED TO MAINTAIN SYNCRONOUSY AMONG ALL THE USERS TO AVOID PROBLEMS

np.unique({array name}) -> this returns a 1d array containing all the unique values in the arg array, arg array can be of any dimension


VIEWING THE ARRAYS AND MATRICES (NDARRAYS)
using the index value -> same as other programming lang
using the slice operator(:) ->array_name[{start:end+1}, {start:end+1}, so on] -> eacj subsequent pair is the dimension for the array_name, starts with d0 to dn-1

MANIPULATING AND COMPARING ARRAYS
Arithemtic manipulation:
Assuming each array has either float or int elements:
+ -> add the corresponding elements  
- -> sub "
* -> multiply "
/ -> divide "
// -> floor div "
** -> power " 
% -> modulus "
There are also some mathematical functions which take arrays as arg:
np.add()
np.square()
All present here : https://numpy.org/doc/stable/reference/routines.math.html

operand arrays in each case has to be either of same dimension or atleast one should be 1d
the smaller array is broadcast across the larger array to make sure that they have compatible arrays for operations
(see jupyter notebook)

Aggregation:
performing a same func over a number of elements here ndarray
remember to use numpy methods over numpy data types and python methods over python data types
=> np.sum(), np.mean(), np.max(), np.min(), np.std(), np.var() -> statistics based methods for a single array as arg
np.sqrt() -> return square root

Standard Deviation and Variance: -> std(), var()

Reshape and Transpose:
arr_name.reshape(({new shape})) -> this returns a new ndarray with a new shape conatining all the elements of arr_name, new shape should be such that each elemet of arr_name is added to new array, numpy will neither add nor deduct any element
arr_name.T
arr_name.transpose(axes) -> axes can be a tuple of ints or None
Transpose -> flips the axes around ie in reverse
reshape -> flips the axes as per new shape such that it satisfies the condition for no. of elements
